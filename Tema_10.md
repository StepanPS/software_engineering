# Тема 10. Декораторы и исключения
Отчет по Теме #10 выполнил:
- Пичкуренко Степан Сергеевич
- АИС-21-1

| Задание | Лаб_раб | Сам_раб |
| ------ | ------ | ------ |
| Задание 1 | + | + |
| Задание 2 | + | + |
| Задание 3 | + | + |
| Задание 4 | + | + |
| Задание 5 | + | + |

Работу проверили:
- к.э.н., доцент Панов М.А.
## Лабораторная работа №1
### Вам нужно написать программу, которая будет считать числа Фибоначчи для 100 и запустить ее без этого декоратора и с ним, посмотреть на разницу во времени решения поставленной задачи.

```python
from functools import lru_cache


@lru_cache(None)
def fibonacci(n):
    if n == 0:
        return 0
    elif n == 1:
        return 1
    return  fibonacci(n - 1) + fibonacci(n -2)


if __name__ == "__main__":
    print(fibonacci(100))
```
### Результат.
![Меню]( https://github.com/StepanPS/software_engineering/blob/master/pic/lab_1.png)

## Лабораторная работа №2
### Напишите декоратор для функции, который будет принимать все параметры вызываемой функции (имя, возраст) и проверять чтобы возраст был больше 0 и меньше 130. Причем заметьте, что неважно сколько пользователь введет данных на сайт к Илье, будут обрабатываться только первые 2 аргумента.

```python
def check(input_func):
    def output_func(*args):
        name, age = args[0], args[1]

        if age < 0 or age > 130:
            age = "Error"
        input_func(name,age)

    return output_func

@check
def personal_info(name, age):
    print(f"Name: {name} Age: {age}")

if __name__ == "__main__":
    personal_info('Vlad', 38)
    personal_info('Alex', -5)
    personal_info('Petr', 1129, 2, 0, 77)
```
### Результат.
![Меню]( https://github.com/StepanPS/software_engineering/blob/master/pic/lab_2.png)

## Лабораторная работа №3
### Воспользуйтесь исключениями, чтобы неподходящий тип данных не ломал ваш сайт. Также дополнительно можете обернуть весь код функции в try/except/finally для того, чтобы программа вас оповестила о том, что выявлена какая-то ошибка или программа успешно выполнена.

```python
def date(*args):
    try:
        for i in range(len(*args)):
            try:
                result = (args[0][i] * 15) // 10
                print(result)
            except Exception as ex:
                print(ex)
    except Exception as ex:
        print(ex)
    finally:
        print('Вся информация обработана')


if __name__ == "__main__":
    date([1, 15, 'Hello', 'i', 'try', 'to', 'crash', 'your', 'site', 38, 45])
```
### Результат.
![Меню]( https://github.com/StepanPS/software_engineering/blob/master/pic/lab_3.png)

## Лабораторная работа №4
### Продолжая работу над сайтом, вы решили написать собственное исключение, которое будет вызываться в случае, если в функцию проверки имени при регистрации передана строка длиннее десяти символов, а если имя имеет допустимую длину, то в консоль выводиться “Успешная регистрация”

```python
class NegftiveValueException(Exception):
    pass


def check_name(name):
    if len(name) > 10:
        raise NegftiveValueException('Длина более 10 символов')
    else:
        print('Успешная регистрация')

if __name__ == '__main__':
    name = '-1'
    check_name(name)
```
### Результат.
![Меню]( https://github.com/StepanPS/software_engineering/blob/master/pic/lab_4.png)

## Лабораторная работа №5
### После запуска сайта вы поняли, что вам необходимо добавить логгер, для отслеживания его работы. Готовыми вариантами вы не захотели пользоваться, и поэтому решили создать очень простую пародию. Для этого создали две функции: __init__() (вызывается при создании класса декоратора в программе) и __call__() (вызывается при вызове декоратора). Создайте необходимый вам декоратор. Выведите все логи в консоль.

```python
class SiteChecker:
    def __init__(self, func):
        print('> Класс SiteChecker метод __init__ успешный запуск')
        self.func = func

    def __call__(self):
        print('> Проверка перед запуском', self.func.__name__)
        self.func()
        print('> Проверка безопасного выключения')

@SiteChecker
def site():
    print('Работа сайта')

if __name__ == "__main__":
    print('>> Сайт запущен')
    site()
    print('>> Сайт выключен')
```
### Результат.
![Меню]( https://github.com/StepanPS/software_engineering/blob/master/pic/lab_5.png)

## Самостоятельная работа №1
### Вовочка решил заняться спортивным программированием на рython, но для этого он должен знать за какое время выполняется его программа. Он решил, что для этого ему идеально подойдет декоратор для функции, который будет выяснять за какое время выполняется та или иная функция. Помогите Вовочке в его начинаниях и напишите такой декоратор. Подсказка: необходимо использовать модуль time
```python
import time


def print_time(func):
    def wrapper(*args, **kwargs):
        start_time: float = time.time()
        result = func(*args, **kwargs)
        end_time: float = time.time()
        print()
        print(f"Время выполнения {func.__name__}: {end_time - start_time} секунд")
        return result
    return wrapper


@print_time
def fibonacci():
    fib1 = fib2 = 1
    for i in range(2, 200):
        fib1, fib2 = fib2, fib1 + fib2
        print(fib2, end=' \n')


if __name__ == '__main__':
    fibonacci()
```
### Результат.
![Меню]( https://github.com/StepanPS/software_engineering/blob/master/pic/ind_1.png)

## Выводы
Код выводит сообщения с найденными значениями. Каждая строчка кода получилась индивидуальной:
1. ` import time `: импортируем модуль time, который позволяет работать со временем.
2. ` def print_time(func): `: определяем функцию-декоратор print_time, которая принимает на вход функцию func.
3. ` def wrapper(*args, **kwargs): `: определяем внутреннюю функцию wrapper, которая будет оберткой для функции func и принимает произвольное количество позиционных и именованных аргументов.
4. ` start_time: float = time.time() `: инициализируем переменную start_time значением текущего времени. Здесь используется аннотация типа float, чтобы указать, что переменная должна иметь тип float.
5. ` result = func(*args, **kwargs) `: вызываем функцию func с переданными аргументами и сохраняем результат в переменную result.
6. ` end_time: float = time.time() `: инициализируем переменную end_time значением текущего времени. Здесь также используется аннотация типа float.
7. ` print() `: выводим пустую строку
8. ` print(f"Время выполнения {func.__name__}: {end_time - start_time} секунд") `: выводим информацию о времени выполнения функции func. Здесь используются f-строки для форматированного вывода.
9. ` return result `: возвращаем результат выполнения функции func.
10. ` return wrapper `: возвращаем результат выполнения функции func.
11. `@print_time `: применяем функцию-декоратор print_time к функции fibonacci.
12. ` def fibonacci(): `: определяем функцию fibonacci, которая будет выводить последовательность чисел Фибоначчи.
13. ` fib1 = fib2 = 1 `: инициализируем переменные fib1 и fib2 значением 1. Это начальные значения последовательности Фибоначчи.
14. ` for i in range(2, 200): `: выполняем цикл от 2 до 199. В каждой итерации цикла вычисляем следующее число Фибоначчи и выводим его.
15. ` fib1, fib2 = fib2, fib1 + fib2 `: обновляем значения fib1 и fib2, чтобы перейти к следующему числу Фибоначчи.
16. ` print(fib2, end=' \n') `: выводим текущее число Фибоначчи. Здесь используется параметр end со значением ' \n', чтобы числа выводились в одной строке.
17. `if __name__ == '__main__':`: точка входа
18. ` fibonacci() `: вызываем функцию fibonacci для вывода последовательности чисел Фибоначчи с информацией о времени выполнения.

## Самостоятельная работа №2
### Посмотрев на Вовочку, вы также загорелись идеей спортивного программирования, начав тренировки вы узнали, что для решения некоторых задач необходимо считывать данные из файлов. Но через некоторое время вы столкнулись с проблемой что файлы бывают пустыми, и вы не получаете вводные данные для решения задачи. После этого вы решили не просто считывать данные из файла, а всю конструкцию оборачивать в исключения, чтобы избежать такой проблемы. Создайте пустой файл и файл, в котором есть какая-то информация. Напишите код программы. Если файл пустой, то, нужно вызвать исключение ("бросить исключение") и вывести в консоль "файл пустой", а если он не пустой, то вывести информацию из файла.
```python
class FileEmptyException(Exception):
    def __init__(self, filename: str):
        message: str = f"Файл {filename} пустой"
        super().__init__(message)


def open_file(filename: str) -> str:
    with open(filename, "r", encoding='utf-8') as f:
        content = f.read()
        if content.strip() == '':
            raise FileEmptyException(filename)
        return content


def main(filename: str) -> None:
    try:
        print(open_file(filename))
    except FileEmptyException as ex:
        print(ex)


if __name__ == '__main__':
    main("No text.txt")
    main("Text.txt")
```
### Результат.
![Меню]( https://github.com/StepanPS/software_engineering/blob/master/pic/ind_2.png)

## Выводы
Код выводит сообщения с найденными значениями. Каждая строчка кода получилась индивидуальной:
1. ` class FileEmptyException(Exception):`: Создается пользовательское исключение FileEmptyException, которое наследуется от класса Exception.
2. ` def init(self, filename: str):`: 
3. ` message: str = f"Файл {filename} пустой"`: В конструкторе исключения устанавливается атрибут message, содержащий сообщение об ошибке, и вызывается конструктор родительского класса Exception с этим сообщением.
4. `super().init(message) `: 
5. ` def open_file(filename: str) -> str:`: Функция open_file принимает имя файла и возвращает его содержимое в виде строки.
6. `with open(filename, "r", encoding='utf-8') as f: `: Открывается файл с заданным именем в режиме чтения и кодировкой utf-8.
7. ` content = f.read()`: Содержимое файла считывается в переменную content.
8. `if content.strip() == '': `: Если содержимое файла, после удаления всех пробельных символов, оказывается пустым, то… 
9. ` raise FileEmptyException(filename)`: выбрасывается исключение FileEmptyException с заданным именем файла.
10. ` return content`: возвращается содержимое файла.
11. `def main(filename: str) -> None: `: Функция main принимает имя файла и не возвращает ничего.
12. ` try:`: В блоке try выполняется вызов функции open_file с заданным именем файла и результат выводится на экран.
13. ` print(open_file(filename))`: 
14. `except FileEmptyException as ex: `: Если происходит исключение FileEmptyException, оно перехватывается в блоке except и выведется на экран.
15. ` print(ex)`: 
16. `if __name__  == '__main__': `: точка входа
17. ` main("No text.txt")`: вызывается функция main с именем файла "No text.txt" 
18. ` main("Text.txt")`: с именем файла "Text.txt".

## Самостоятельная работа №3
### Напишите функцию, которая будет складывать 2 и введенное пользователем число, но если пользователь введет строку или другой неподходящий тип данных, то в консоль выведется ошибка "Неподходящий тип данных. Ожидалось число.". Реализовать функционал программы необходимо через try/except и подобрать правильный тип исключения. Создавать собственное исключение нельзя. Проведите несколько тестов, в которых исключение вызывается и нет. Результатом выполнения задачи будет листинг кода и получившийся вывод в консоль
```python
def sum_with_user_input():
    try:
        num = float(input("Введите число: "))
        result = int(2 + num)
        print(f"Результат: {result}")
    except ValueError:
        print("Неподходящий тип данных. Ожидалось число.")


if __name__ == '__main__':
    sum_with_user_input()
```
### Результат.
![Меню]( https://github.com/StepanPS/software_engineering/blob/master/pic/ind_3_1.png)
![Меню]( https://github.com/StepanPS/software_engineering/blob/master/pic/ind_3_2.png)

## Выводы
Код выводит сообщения с найденными значениями. Каждая строчка кода получилась индивидуальной:
1. ` def sum_with_user_input(): `: функция: sum_with_user_input
2. ` try: `: 
3. ` num = float(input("Введите число: ")) `: вводим число с клавиатуры
4. ` result = int(2 + num) `: складываем 2 и введенное число
5. ` print(f"Результат: {result}") `: выводим результат
6. ` except ValueError:`: обрабатываем исключение, если введен неподходящий тип данных
7. ` print("Неподходящий тип данных. Ожидалось число.") `: 
8. ` if __name__ == '__main__': `: Точка входа
9. ` sum_with_user_input() `: для функции: sum_with_user_input

## Самостоятельная работа №4
### Создайте собственный декоратор, который будет использоваться для двух любых вами придуманных функций. Декораторы, которые использовались ранее в работе нельзя воссоздавать. Результатом выполнения задачи будет: класс декоратора, две как-то связанными с ним функциями, скриншот консоли с выполненной программой и подробные комментарии, которые будут описывать работу вашего кода.
```python
class MyDecorator:
    def __init__(self, func):
        self.func = func

    def __call__(self, *args, **kwargs):
        print(f"Вызвана функция '{self.func.__name__}' с аргументами: {args}, {kwargs}")
        return self.func(*args, **kwargs)

@MyDecorator
def sum_numbers(a):
    return a * a

@MyDecorator
def multiply_numbers(a, b):
    return a + b


print(sum_numbers(2))
print(multiply_numbers(4, 5))
```
### Результат.
![Меню]( https://github.com/StepanPS/software_engineering/blob/master/pic/ind_4.png)

## Выводы
Код выводит сообщения с найденными значениями. Каждая строчка кода получилась индивидуальной:
1. ` class MyDecorator: `: Создание класса-декоратора MyDecorator
2. ` def __init__(self, func): `: Конструктор класса-декоратора, принимает на вход декорируемую функцию и сохраняет ее в атрибуте self.func
3. ` self.func = func `: 
4. ` def __call__(self, *args, **kwargs): `: Метод call класса-декоратора, вызывается при вызове декорированной функции. Выводится сообщение о вызове функции и ее аргументах. Затем вызывается оригинальная функция и возвращается ее результат.
5. ` print(f"Вызвана функция '{self.func.__name__}' с аргументами: {args}, {kwargs}")`: 
6. ` return self.func(*args, **kwargs)`: 
7. `@MyDecorator `: 
8. ` def sum_numbers(a): `: Декорирование функции sum_numbers с помощью класса-декоратора MyDecorator
9. ` return a * a `: возвращает: а * а
10. `@MyDecorator `: 
11. ` def multiply_numbers(a, b): `: Декорирование функции multiply_numbers с помощью класса-декоратора MyDecorator
12. ` return a + b `: возвращает: а + b
13. ` print(sum_numbers(2)) `: Вызов декорированной функции sum_numbers с аргументом 2
14. ` print(multiply_numbers(4, 5)) `: Вызов декорированной функции multiply_numbers с аргументами 4 и 5

## Самостоятельная работа №5
### Создайте собственное исключение, которое будет использоваться в двух любых фрагментах кода. Исключения, которые использовались ранее в работе нельзя воссоздавать. Результатом выполнения задачи будет: класс исключения, код к котором в двух местах используется это исключение, скриншот консоли с выполненной программой и подробные комментарии, которые будут описывать работу вашего кода.
```python
class CustomException(Exception):
    pass

try:
    # Фрагмент кода 1
    number = int(input("Введите число: "))
    if number % 2 != 0:
        raise CustomException("Введено нечетное число!")
    else:
        print("Введено четное число.")
except CustomException as e:
    print(e)

try:
    # Фрагмент кода 2
    name = input("Введите имя: ")
    if name == "":
        raise CustomException("Имя не может быть пустым!")
    else:
        print(f"Привет, {name}!")
except CustomException as e:
    print(e)
```
### Результат.
![Меню]( https://github.com/StepanPS/software_engineering/blob/master/pic/ind_5.png)

## Выводы
Код выводит сообщения с найденными значениями. Каждая строчка кода получилась индивидуальной:
1. `class CustomException(Exception): `: Создается класс CustomException наследующий от класса Exception
2. `pass `: Пустой блок кода
3. `try: `: 
4. ` number = int(input("Введите число: "))`: Ввод числа с клавиатуры
5. `if number % 2 != 0: `: С помощью оператора % проверяется, является ли число четным или нечетным.
6. `raise CustomException("Введено нечетное число!") `: Если число нечетное, генерируется исключение CustomException с сообщением "Введено нечетное число!".
7. `else: `: Иначе…
8. `print("Введено четное число.") `: выводит сообщение
9. ` except CustomException as e:`: Переменная “e” содержит информацию об ошибке
10. ` print(e)`: Выводит переменную “e”
11. ` `:  C 11 по 18 пункт комментарии индентичны

## Общие выводы по теме 
В результате окончания изучения Темы 10, я получил знания позволяющие работать с декораторами и исключениями. Декораторы оказались мощным инструментом для модификации функционала функций, делая код более гибким и поддерживаемым. А исключения, в свою очередь, предоставили мне эффективный механизм обработки ошибок. Освоив основные конструкции, такие как try, except и finally, я научился более гибко управлять потоком выполнения программы в случае возникновения проблем. Также, я освоил создание пользовательских исключений для более точного контроля ошибок.
